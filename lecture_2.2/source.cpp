#include <iostream>

struct Person
{
	std::string name;
	int age;
};

class person							// Обьявили класс
{
public:									// Это слово отличает класс от структуры. После слова public все, что содержится в класссе - станет видимым для пользователя
	std::string name;
	int age;
};

// Пример обьявления класса с public и private. Этими двумя словами можно разделять поля (переменные) внутри класса от видимых и невидимых - скрытых.
/*
class Animal
{
public:						// Сможем обращаться к этим переменным за пределами этого класса
	std::string;
	int age;
private:
	int tail;				// Не сможем обращаться к этой переменной за пределами этого класса
}
*/

class Animal
{
public:
	std::string name;
	int age;
	int tail;
};

class Cat
{
public:
	std::string name;
	int age;

	void meow()								// Действия, происходимые в классе - методы. Т.е функции, написанные в классе определяют его поведение - это называется метод
	{
		std::cout << name << " said: Meow!" << std::endl;  // Сначала просто "said: Meow!", потом добавили вывод имени name.
	}
};

class Dog
{
public:
	std::string name;
	int age;
	
	// Dog (){}			// Так выглядит конструктор по умолчанию.

	Dog()				// Конструктор по умолчанию. Проверим выводится ли он при обьявлении обьекта класса Dog.
	{
		name = "unknown";
		age = 0;
		std::cout << "Конструктор1" << std::endl;
	}
	void gaf()
	{
		std::cout << name << " said: Gaf!" << " age: " << age << std::endl;
	}
};


class Dog1
{
public:
	std::string name;
	int age;

	Dog1(std::string any_name, int any_age)			// Конструктор по умолчанию. При обьявлении обекта данного класса в него передается имя и возраст начальные.
	{
		name = any_name;
		age = any_age;
		std::cout << "Конструктор1 Если при обьявлении обьекта класса в конуструктор передаются данные." << " age: " << age << std::endl;
	}
	Dog1()			// Конструктор по умолчанию. При обьявлении обекта данного класса в него передается имя и возраст начальные.
	{
		
		std::cout << "Конструктор2 Если при обьявлении обьекта класса в конуструктор не передаются данные." << " age: " << age << std::endl;
	}
	void gaf_gaf()
	{
		std::cout << name << " said: Gaf-Gaf!" << " age: " << age << std::endl;
	}
};

class A
{
public:
	void foo1()
	{
		std::cout << "Используются элементы, находящиеся под public" << std::endl;
	}
	void foo4()					// Функция для обращения к элементам public, private, protected.
	{
		foo1();
		foo2();
		foo3();

	}
private:
	void foo2()
	{
		std::cout << "Используются элементы, находящиеся под private" << std::endl;
	}
protected:
	void foo3()
	{
		std::cout << "Используются элементы, находящиеся под protected" << std::endl;
	}
};

class B
{
	
private:
	int a = 63;
public:

	B()
	{
		std::cout << a << std::endl;
	}
	B(int b)
	{
		this -> a = b;
	}
void print_private()
{
	std::cout << a << std::endl;
}
};

class C
{
private:
	int a = 3;
public:
	int get_a()
	{
		return a;
	}
	void set_a(int c)
	{
		if (c > 0)
		{
			this -> a = c;
		}
	}
};

int main()
{
	setlocale(0, "");
	Person a;
	a.name = "Иван";
	std::cout << a.name << std::endl;

	person b;
	b.name = "Иван";
	std::cout << b.name << std::endl;

	Cat cat1;
	cat1.name = "Barsik";

	// Только обекты класса, в котором обьявлен метод, могут пользоваться данными методами. Отличие от простых функций, которые можно было вызвать в любое время.
	cat1.meow();

	// Обьявим еще один объект класса Cat - вторая кошка Мурка. Дадим ей имя. В поле класса void meow() добавим вывод имени каждой кошки -> std::cout << name << " said: Meow!" << std::endl;
	Cat murka;
	murka.name = "Murka";
	murka.meow();					// В консоль выведется "Murka said: Meow!"


	// Конструктор - специальный метод, который вызывается при создании объекта.
	// В нем пишется код, который должен быть выполнен во время создания экземпляра класса.
	// 
	// Конструктор по умолчанию - вызывается, когда обьект класса в превый раз обьявляется.
	// Любой конструктор содержит в себе парамаетры переменных изначения, которые используются для заполнения не инициализированных полей класса.
	// Посмотрим на конструктор по умолчанию. Он не принимает никаких параметров в себя.
	std::cout << std::endl;
	Dog dog1;						// В консоли увидели "Конструктор1".

	std::cout << std::endl;
	Dog dog2;
	dog2.name = "Bobik";			// Инициализировали переменную name. 
									// Сначала выполнится все согласно Конструктору по умолчанию, далее метод gaf(), использующий переменную name использует ее новое значение "Bobik".
	dog2.gaf();


	// В конструктор можно передавать значения для переменных.
	// Перегузка методов  
	std::cout << std::endl;
	Dog1 dog_1("Sharik", 5);		// При обьявлении обьекта класса в конструктор по умолчанию передали name и age. Автоматически был выбран "Конструктор1", более подходящий для данного обьекта.
	dog_1.gaf_gaf();

	Dog1 dog_2;						// При обьявлении обьекта класса в конструктор по умолчанию ничего не передали. Автоматически был выбран "Конструктор2", более подходящий для данного обьекта.
	dog_2.gaf_gaf();
	
	// Конструкторов внутри одного класса может быть большое количество, и какой именно будет использован определяется по принципу самый подходящий. 
	// Пример
	// std::string str();		// Строка может быть инициализирована 18 разными способами, т.е может быть выбран 1 из 18 конструкторов.
	std::cout << std::endl;
	std::string str(50, '_');
	std::cout << str << std::endl;

	std::string str1("Hello!");
	std::cout << str1 << std::endl;

	std::string str2({ 'S', 'a', 'l', 'u', 't' });
	std::cout << str2 << std::endl;
	 
	
	// Если мы не обьявляли в классе конструкторы, то по умолчанию только один конструктор Dog1(){}.
	////ПРОВЕРИТЬ!!! // Если обьявили хотя бы 1 конструктор, то также имеем 2 конструктора для созданного класса: 
	// Dog1(const Dog1 &) -> конструктор на основе ссылки на ранее созданный конструктор.
	// Dog1(Dog1 &&0 -> конструктор на основе ссылки на ранее созданный конструктор конструктор на основе ранее обьявленного обьекта этого же класса.
	Dog1 dog_3();

	// При инициализации обьекта, если он принимает несколько значений, то их нужно вводить по порядку. Конструктор работает с переданными значениями по порядку.
	
	// Использование this. Используется для:
	// 1) Точное указание внутри класса на параметр класса - переменная, описывающая свойство задействованного объекта.
	/*
class Dog1
{
public:
/	// Параметры класса//
	std::string name;
	int age;

	Dog1(std::string name, int age)			
	{
		//Поля класса//
		this->name = name;						// "this->" указывает на адрес параметра name класса Dog1.
		this->age = age;						// "this->" указывает на адрес параметра age класса Dog1.
		std::cout << "Конструктор1 " << std::endl;
	}
};
	*/

	// 2)  Метод в классе, который возвращает сам себя.
	// Dog1* myself()
	// {
	//	 return this;
	// }


	std::cout << std::endl;
	// Модификаторы доступа public, private, protected
	// public -> означает, что помеченные им члены класса доступны любому коду (вне этого класса).
	// private -> означает, что помеченные им члены доступны только коду внутри класса (данные под этим модификатором доступны только методам и полям внутри самого класса).
	// protected -> означает, что помеченные им члены доступны коду внутри класса и внутри его наследников.
	A obj;
	obj.foo1();				// Для public - в консоль выведется "Используются элементы, находящиеся под public"
	// obj.foo2();			// Для private - Ошибка. К этим элементам нельзя обратиться вне класса.
	// obj.foo3();			// Для protected - Ошибка. К этим элементам нельзя обратиться вне класса.
	
	// Зато метод foo4() (находится в public) может обратиться к элементам из private и protected, т.к является элементом экземпляра obj класса A. 
	obj.foo4();
	
	std::cout << std::endl;
	// Если внутри класса обьявить конструктор, передавать в него переменную и внутри него присвоить это значение полю private, то оно изменится.
	B object1;						//В консоль выведется число 63 (как указано в поле private).

	B object2(36);					//В приватном поле записано число 63. Инициализировали экземпляр object класса B, передали значение 36 в конструктор.
	object2.print_private();		//В консоль выведется число 36. 



	std::cout << std::endl;
	// Геттеры и сеттеры - методы в public, позволяющие обращаться к полям private и protected.
	// Геттеры - прочитать значение снаружи класса.
	// Сеттеры - записать значение снаружи класса.
	C get_set;
	std::cout << get_set.get_a() << std::endl;

	get_set.set_a(77);
	std::cout << get_set.get_a() << std::endl;


	// Констатные обьект могут вызывать только константные методы
	// const C getter;		
	// std::cout << getter.get_a() << std::endl;			//в классе метод должен тоже содержать const -> int get_a() const {return a}.

	








}	
